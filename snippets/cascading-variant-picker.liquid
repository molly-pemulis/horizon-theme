{% comment %}
  CASCADING VARIANT PICKER
  ========================
  - Renders all options server-side (like standard picker)
  - Uses swatch snippet for consistent styling
  - JavaScript hides unavailable options (pruning)
  - Shows variant photos after picking prior options

  Usage: {% render 'cascading-variant-picker', product_resource: product %}
{% endcomment %}

{% liquid
  assign product = product_resource
  if product == blank
    assign product = closest.product
  endif

  if product == blank and request.visual_preview_mode
    assign product = collections.all.products.first
  endif
%}

{% unless product.has_only_default_variant %}
  <cascading-variant-picker
    class="cascading-picker"
    data-product-id="{{ product.id }}"
    data-product-url="{{ product.url }}"
    data-section-id="{{ section.id }}"
  >
    {%- comment -%} JSON data for JavaScript {%- endcomment -%}
    <script type="application/json" data-variants>
      [
        {%- for variant in product.variants -%}
          {%- if variant.available -%}
            {
              "id": {{ variant.id }},
              "options": {{ variant.options | json }},
              "price": {{ variant.price }},
              "compare_at_price": {{ variant.compare_at_price | default: 'null' }},
              "sku": {{ variant.sku | json }},
              "featured_image": {% if variant.featured_image %}{{ variant.featured_image | image_url: width: 800 | json }}{% else %}null{% endif %}
            }{% unless forloop.last %},{% endunless %}
          {%- endif -%}
        {%- endfor -%}
      ]
    </script>

    <form class="cascading-picker__form">
      {%- for option in product.options_with_values -%}
        {% assign option_index = forloop.index0 %}
        {% assign swatch_count = option.values | map: 'swatch' | compact | size %}
        {% assign has_swatches = false %}
        {% if swatch_count > 0 %}
          {% assign has_swatches = true %}
        {% endif %}

        {%- comment -%} Check if this option has variant images {%- endcomment -%}
        {% assign has_variant_images = false %}
        {% for value in option.values %}
          {% if value.variant.featured_media != blank %}
            {% assign has_variant_images = true %}
            {% break %}
          {% endif %}
        {% endfor %}

        {% assign use_swatches = false %}
        {% if has_swatches or has_variant_images %}
          {% assign use_swatches = true %}
        {% endif %}

        <fieldset
          class="cascading-picker__option{% if use_swatches %} cascading-picker__option--swatches{% endif %}"
          data-option-index="{{ option_index }}"
          {% if option_index > 0 %}disabled{% endif %}
        >
          <legend>
            {{ option.name }}
            <span class="cascading-picker__selected-value" data-selected-label></span>
          </legend>

          <div class="cascading-picker__values{% if use_swatches %} cascading-picker__values--swatches{% endif %}">
            {%- for value in option.values -%}
              {% liquid
                # Get the variant for this option value to access its image
                assign value_variant = value.variant
                assign featured_media = value_variant.featured_media

                # Check if this value leads to any available variant
                assign value_available = false
                for variant in product.variants
                  if variant.available and variant.options[option_index] == value
                    assign value_available = true
                    break
                  endif
                endfor
              %}

              <label
                class="cascading-picker__label{% if use_swatches %} cascading-picker__label--swatch{% endif %}{% unless value_available %} cascading-picker__label--unavailable{% endunless %}"
                data-option-value="{{ value | escape }}"
                data-option-index="{{ option_index }}"
                {% unless value_available %}data-unavailable="true"{% endunless %}
              >
                <input
                  type="radio"
                  name="option{{ forloop.parentloop.index }}"
                  value="{{ value | escape }}"
                  data-option-index="{{ option_index }}"
                  {% unless value_available %}disabled{% endunless %}
                >

                {% if use_swatches %}
                  {%- comment -%} Use same rendering as standard picker {%- endcomment -%}
                  {% render 'swatch',
                    swatch: value.swatch,
                    variant_image: featured_media,
                    mode: 'unscaled'
                  %}
                  <span class="cascading-picker__value-name visually-hidden">{{ value }}</span>
                {% else %}
                  <span class="cascading-picker__value-text">{{ value }}</span>
                {% endif %}
              </label>
            {%- endfor -%}
          </div>
        </fieldset>
      {%- endfor -%}

      <input type="hidden" name="id" value="" data-selected-variant-id>
    </form>
  </cascading-variant-picker>
{% endunless %}

<script>
  class CascadingVariantPicker extends HTMLElement {
    constructor() {
      super();
      this.variants = [];
      this.selections = [];
      this.optionCount = 0;
    }

    connectedCallback() {
      const variantsScript = this.querySelector('script[data-variants]');
      if (variantsScript) {
        this.variants = JSON.parse(variantsScript.textContent);
      }

      const fieldsets = this.querySelectorAll('fieldset');
      this.optionCount = fieldsets.length;
      this.selections = new Array(this.optionCount).fill(null);

      // Bind radio changes
      this.querySelectorAll('input[type="radio"]').forEach(radio => {
        radio.addEventListener('change', this.handleChange.bind(this));
      });

      // Initial prune - hide unavailable options for first fieldset
      this.pruneOptions(0);
    }

    handleChange(event) {
      const radio = event.target;
      const optionIndex = parseInt(radio.dataset.optionIndex);
      const value = radio.value;

      this.selections[optionIndex] = value;

      // Clear selections after this one
      for (let i = optionIndex + 1; i < this.optionCount; i++) {
        this.selections[i] = null;
        // Uncheck radios in subsequent fieldsets
        const fieldset = this.querySelector(`fieldset[data-option-index="${i}"]`);
        if (fieldset) {
          fieldset.querySelectorAll('input[type="radio"]').forEach(r => r.checked = false);
        }
      }

      // Update labels
      this.updateLabels();

      // Enable and prune next fieldsets
      for (let i = optionIndex + 1; i < this.optionCount; i++) {
        const fieldset = this.querySelector(`fieldset[data-option-index="${i}"]`);
        if (fieldset) {
          fieldset.disabled = false;
          this.pruneOptions(i);
        }
      }

      // Update main image if variant has one
      this.updateMainImage();

      // Check if complete
      this.checkComplete();
    }

    pruneOptions(optionIndex) {
      const availableValues = this.getAvailableValues(optionIndex);
      const fieldset = this.querySelector(`fieldset[data-option-index="${optionIndex}"]`);
      if (!fieldset) return;

      const labels = fieldset.querySelectorAll('.cascading-picker__label');
      labels.forEach(label => {
        const value = label.dataset.optionValue;
        const radio = label.querySelector('input[type="radio"]');

        if (availableValues.includes(value)) {
          label.style.display = '';
          label.classList.remove('cascading-picker__label--unavailable');
          if (radio) radio.disabled = false;
        } else {
          label.style.display = 'none';
          label.classList.add('cascading-picker__label--unavailable');
          if (radio) radio.disabled = true;
        }
      });

      // Auto-select if only one option available
      if (availableValues.length === 1 && !fieldset.disabled) {
        const onlyLabel = fieldset.querySelector(`.cascading-picker__label[data-option-value="${CSS.escape(availableValues[0])}"]`);
        const radio = onlyLabel?.querySelector('input[type="radio"]');
        if (radio && !radio.checked) {
          radio.checked = true;
          radio.dispatchEvent(new Event('change', { bubbles: true }));
        }
      }
    }

    getAvailableValues(optionIndex) {
      let matchingVariants = this.variants;

      // Filter by prior selections
      for (let i = 0; i < optionIndex; i++) {
        if (this.selections[i] !== null) {
          matchingVariants = matchingVariants.filter(v => v.options[i] === this.selections[i]);
        }
      }

      // Get unique values at this option index
      return [...new Set(matchingVariants.map(v => v.options[optionIndex]))];
    }

    updateLabels() {
      this.querySelectorAll('[data-selected-label]').forEach((label, i) => {
        label.textContent = this.selections[i] ? `: ${this.selections[i]}` : '';
      });
    }

    updateMainImage() {
      // Find matching variant based on current selections
      const matchingVariant = this.variants.find(v => {
        for (let i = 0; i < this.selections.length; i++) {
          if (this.selections[i] !== null && v.options[i] !== this.selections[i]) {
            return false;
          }
        }
        return true;
      });

      if (matchingVariant?.featured_image) {
        const mainImage = document.querySelector('.product-media__image');
        if (mainImage) {
          mainImage.src = matchingVariant.featured_image;
          mainImage.srcset = '';
        }
      }
    }

    checkComplete() {
      const hiddenInput = this.querySelector('[data-selected-variant-id]');
      const allSelected = this.selections.every(s => s !== null);

      if (allSelected) {
        const variant = this.variants.find(v =>
          v.options.every((opt, i) => opt === this.selections[i])
        );

        if (variant) {
          hiddenInput.value = variant.id;

          // Dispatch events for add-to-cart button
          this.dispatchEvent(new CustomEvent('variant:selected', {
            bubbles: true,
            detail: { variant, sectionId: this.dataset.sectionId }
          }));

          this.dispatchEvent(new CustomEvent('variant:update', {
            bubbles: true,
            detail: {
              resource: {
                id: variant.id,
                available: true,
                price: variant.price,
                compare_at_price: variant.compare_at_price,
                sku: variant.sku,
                featured_media: variant.featured_image ? {
                  preview_image: { src: variant.featured_image }
                } : null
              },
              sourceId: this.dataset.sectionId,
              data: {
                productId: this.dataset.productId,
                html: document
              }
            }
          }));
        }
      } else {
        hiddenInput.value = '';

        this.dispatchEvent(new CustomEvent('variant:update', {
          bubbles: true,
          detail: {
            resource: null,
            sourceId: this.dataset.sectionId,
            data: {
              productId: this.dataset.productId,
              html: document
            }
          }
        }));
      }
    }
  }

  if (!customElements.get('cascading-variant-picker')) {
    customElements.define('cascading-variant-picker', CascadingVariantPicker);
  }
</script>

{% stylesheet %}
  .cascading-picker {
    width: 100%;
  }

  .cascading-picker__form {
    display: flex;
    flex-direction: column;
    gap: var(--gap-md, 16px);
  }

  .cascading-picker__option {
    border: none;
    padding: 0;
    margin: 0;
  }

  .cascading-picker__option:disabled {
    opacity: 0.5;
    pointer-events: none;
  }

  .cascading-picker__option legend {
    padding: 0;
    margin-bottom: var(--margin-2xs, 4px);
    font-weight: var(--font-weight-semibold, 600);
  }

  .cascading-picker__selected-value {
    font-weight: normal;
    color: rgb(var(--color-foreground-rgb, 0 0 0) / 0.7);
  }

  .cascading-picker__values {
    display: flex;
    flex-wrap: wrap;
    gap: var(--gap-sm, 8px);
  }

  /* Text button style (non-swatch) */
  .cascading-picker__label {
    position: relative;
    cursor: pointer;
  }

  .cascading-picker__label input[type="radio"] {
    position: absolute;
    opacity: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
  }

  .cascading-picker__value-text {
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 3.25em;
    min-height: 3.25em;
    padding: var(--padding-sm, 8px) var(--padding-lg, 16px);
    border: var(--style-border-width-inputs, 1px) solid var(--color-border, #ccc);
    border-radius: var(--style-border-radius-inputs, 4px);
    background: var(--color-background, #fff);
    transition: border-color 0.15s ease, background-color 0.15s ease;
  }

  .cascading-picker__label:hover .cascading-picker__value-text {
    border-color: var(--color-foreground, #000);
  }

  .cascading-picker__label:has(input:checked) .cascading-picker__value-text {
    border-color: var(--color-foreground, #000);
    background-color: var(--color-foreground, #000);
    color: var(--color-background, #fff);
  }

  /* Swatch style */
  .cascading-picker__label--swatch {
    width: var(--variant-picker-swatch-width, 44px);
    height: var(--variant-picker-swatch-height, 44px);
  }

  .cascading-picker__label--swatch .swatch {
    width: 100%;
    height: 100%;
    border-radius: var(--variant-picker-swatch-radius, 50%);
    transition: outline 0.15s ease;
  }

  .cascading-picker__label--swatch:hover .swatch {
    outline: 2px solid rgb(var(--color-foreground-rgb, 0 0 0) / 0.35);
    outline-offset: 2px;
  }

  .cascading-picker__label--swatch:has(input:checked) .swatch {
    outline: 2px solid var(--color-foreground, #000);
    outline-offset: 2px;
  }

  .cascading-picker__label--unavailable {
    display: none;
  }

  .visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
{% endstylesheet %}

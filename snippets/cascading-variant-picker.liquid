{% comment %}
  CASCADING VARIANT PICKER
  ========================
  - Prunes unavailable variants
  - First option: dropdown (forces selection)
  - Color option: thumbnail swatches (detects by name or variant images)
  - Clicking color thumbnail updates main product image
  - Fallback to dropdown if no variant images
  
  Usage: {% render 'cascading-variant-picker', product_resource: product %}
{% endcomment %}

{% liquid
  assign product = product_resource
  if product == blank
    assign product = closest.product
  endif
  
  if product == blank and request.visual_preview_mode
    assign product = collections.all.products.first
  endif
  
  # Detect which option is "color" - check name or if variants have images
  assign color_option_index = -1
  for option in product.options_with_values
    assign option_name_lower = option.name | downcase
    if option_name_lower contains 'color' or option_name_lower contains 'colour'
      assign color_option_index = forloop.index0
      break
    endif
  endfor
  
  # If no color option found by name, check if any option's variants have unique images
  if color_option_index == -1
    for option in product.options_with_values
      assign has_variant_images = false
      for variant in product.variants
        if variant.featured_image != blank
          assign has_variant_images = true
          break
        endif
      endfor
      if has_variant_images
        assign color_option_index = forloop.index0
        break
      endif
    endfor
  endif
%}

{% unless product.has_only_default_variant %}
  <cascading-variant-picker
    class="cascading-picker"
    data-product-id="{{ product.id }}"
    data-product-url="{{ product.url }}"
    data-section-id="{{ section.id }}"
    data-color-option-index="{{ color_option_index }}"
  >
    <script type="application/json" data-variants>
      [
        {%- assign first_available = true -%}
        {%- for variant in product.variants -%}
          {%- if variant.available -%}
            {%- unless first_available -%},{%- endunless -%}
            {%- assign first_available = false -%}
            {
              "id": {{ variant.id }},
              "options": {{ variant.options | json }},
              "price": {{ variant.price }},
              "compare_at_price": {{ variant.compare_at_price | default: 'null' }},
              "sku": {{ variant.sku | json }},
              "featured_image": {% if variant.featured_image %}{"url": {{ variant.featured_image | image_url: width: 800 | json }}, "thumb": {{ variant.featured_image | image_url: width: 100 | json }}, "alt": {{ variant.featured_image.alt | default: variant.title | json }}}{% else %}null{% endif %}
            }
          {%- endif -%}
        {%- endfor -%}
      ]
    </script>
    
    <script type="application/json" data-options>
      {{ product.options_with_values | json }}
    </script>

    <form class="cascading-picker__form">
      {%- for option in product.options_with_values -%}
        {% assign option_index = forloop.index0 %}
        {% assign is_color_option = false %}
        {% if option_index == color_option_index %}
          {% assign is_color_option = true %}
        {% endif %}
        
        <div class="cascading-picker__option" 
             data-option-index="{{ option_index }}"
             data-is-color="{{ is_color_option }}">
          <label>
            {{ option.name }}
            <span class="cascading-picker__selected-value" data-selected-label></span>
          </label>
          
          {% if is_color_option %}
            {%- comment -%} Color swatches - will be populated by JS {%- endcomment -%}
            <div class="cascading-picker__swatches" 
                 data-option-index="{{ option_index }}"
                 {% if option_index > 0 %}data-disabled="true"{% endif %}>
              {%- comment -%} JS populates these {%- endcomment -%}
            </div>
            <input type="hidden" name="option{{ forloop.index }}" data-option-index="{{ option_index }}" value="">
          {% else %}
            {%- comment -%} Regular dropdown {%- endcomment -%}
            <div class="cascading-picker__select-wrapper">
              <select
                name="option{{ forloop.index }}"
                data-option-index="{{ option_index }}"
                {% if option_index > 0 %}disabled{% endif %}
              >
                <option value="" selected disabled>
                  Select {{ option.name }}
                </option>
                {%- if option_index == 0 -%}
                  {%- assign shown_values = '' -%}
                  {%- for variant in product.variants -%}
                    {%- if variant.available -%}
                      {%- assign option_value = variant.options[0] -%}
                      {%- unless shown_values contains option_value -%}
                        <option value="{{ option_value | escape }}">{{ option_value }}</option>
                        {%- capture shown_values -%}{{ shown_values }}|{{ option_value }}{%- endcapture -%}
                      {%- endunless -%}
                    {%- endif -%}
                  {%- endfor -%}
                {%- endif -%}
              </select>
              <svg class="cascading-picker__caret" viewBox="0 0 10 6" aria-hidden="true">
                <path d="M1 1l4 4 4-4" stroke="currentColor" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </div>
          {% endif %}
        </div>
      {%- endfor -%}
      
      <input type="hidden" name="id" value="" data-selected-variant-id>
    </form>
  </cascading-variant-picker>
{% endunless %}

<script>
  class CascadingVariantPicker extends HTMLElement {
    constructor() {
      super();
      this.variants = [];
      this.options = [];
      this.selections = [];
      this.colorOptionIndex = -1;
    }

    connectedCallback() {
      const variantsScript = this.querySelector('script[data-variants]');
      const optionsScript = this.querySelector('script[data-options]');
      
      if (variantsScript) this.variants = JSON.parse(variantsScript.textContent);
      if (optionsScript) this.options = JSON.parse(optionsScript.textContent);
      
      this.colorOptionIndex = parseInt(this.dataset.colorOptionIndex) || -1;
      this.selections = new Array(this.options.length).fill(null);
      
      // Bind dropdown changes
      this.querySelectorAll('select').forEach(select => {
        select.addEventListener('change', this.handleChange.bind(this));
      });
      
      // Initialize color swatches if color is first option
      if (this.colorOptionIndex === 0) {
        this.renderColorSwatches(0);
      }
    }

    handleChange(event) {
      const select = event.target;
      const optionIndex = parseInt(select.dataset.optionIndex);
      const value = select.value;
      
      this.selections[optionIndex] = value;
      
      // Clear selections after this one
      for (let i = optionIndex + 1; i < this.selections.length; i++) {
        this.selections[i] = null;
      }
      
      this.updateDropdowns(optionIndex);
      this.updateLabels();
      this.checkComplete();
    }

    handleSwatchClick(event) {
      const swatch = event.currentTarget;
      const optionIndex = parseInt(swatch.dataset.optionIndex);
      const value = swatch.dataset.value;
      const imageUrl = swatch.dataset.imageUrl;
      
      // Update selection
      this.selections[optionIndex] = value;
      
      // Update hidden input
      const hiddenInput = this.querySelector(`input[type="hidden"][data-option-index="${optionIndex}"]`);
      if (hiddenInput) hiddenInput.value = value;
      
      // Update active state
      const swatchContainer = swatch.closest('.cascading-picker__swatches');
      swatchContainer.querySelectorAll('.cascading-picker__swatch').forEach(s => {
        s.classList.remove('cascading-picker__swatch--active');
      });
      swatch.classList.add('cascading-picker__swatch--active');
      
      // Clear selections after this one
      for (let i = optionIndex + 1; i < this.selections.length; i++) {
        this.selections[i] = null;
      }
      
      // Update main product image
      if (imageUrl) {
        this.updateMainImage(imageUrl);
      }
      
      this.updateDropdowns(optionIndex);
      this.updateLabels();
      this.checkComplete();
    }

    updateMainImage(imageUrl) {
      // Try multiple selectors for the main product image
      const mainImage = document.querySelector(
        '.product-media-gallery__image img, ' +
        '.media-gallery img, ' +
        '[data-product-media] img, ' +
        '.product__media img'
      );
      
      if (mainImage) {
        mainImage.src = imageUrl;
        mainImage.srcset = '';
      }
      
      // Dispatch event for other components
      this.dispatchEvent(new CustomEvent('variant:image-changed', {
        bubbles: true,
        detail: { imageUrl }
      }));
    }

    updateDropdowns(fromIndex) {
      for (let i = fromIndex + 1; i < this.options.length; i++) {
        const isColorOption = i === this.colorOptionIndex;
        
        if (isColorOption) {
          this.renderColorSwatches(i);
        } else {
          this.updateSelectDropdown(i);
        }
      }
    }

    renderColorSwatches(optionIndex) {
      const container = this.querySelector(`.cascading-picker__swatches[data-option-index="${optionIndex}"]`);
      if (!container) return;
      
      const availableValues = this.getAvailableValuesWithImages(optionIndex);
      const previousSelected = optionIndex === 0 || this.selections[optionIndex - 1] !== null;
      
      container.innerHTML = '';
      container.dataset.disabled = !previousSelected;
      
      if (!previousSelected) return;
      
      // Check if ANY values have images
      const hasAnyImages = availableValues.some(v => v.image);
      
      availableValues.forEach(({ value, image }) => {
        const swatch = document.createElement('button');
        swatch.type = 'button';
        swatch.className = 'cascading-picker__swatch';
        swatch.dataset.optionIndex = optionIndex;
        swatch.dataset.value = value;
        
        if (image) {
          swatch.dataset.imageUrl = image.url;
          swatch.innerHTML = `<img src="${image.thumb}" alt="${image.alt || value}" loading="lazy">`;
        } else {
          // No image - show color name in square
          swatch.classList.add('cascading-picker__swatch--text');
          swatch.innerHTML = `<span>${value}</span>`;
        }
        
        swatch.addEventListener('click', this.handleSwatchClick.bind(this));
        container.appendChild(swatch);
      });
      
      // If no images at all, fall back to dropdown (replace swatches container)
      if (!hasAnyImages && availableValues.length > 0) {
        this.convertToDropdown(optionIndex, availableValues);
      }
    }

    convertToDropdown(optionIndex, availableValues) {
      const optionContainer = this.querySelector(`.cascading-picker__option[data-option-index="${optionIndex}"]`);
      const swatchContainer = optionContainer.querySelector('.cascading-picker__swatches');
      const hiddenInput = optionContainer.querySelector('input[type="hidden"]');
      
      // Create select element
      const wrapper = document.createElement('div');
      wrapper.className = 'cascading-picker__select-wrapper';
      
      const select = document.createElement('select');
      select.name = `option${optionIndex + 1}`;
      select.dataset.optionIndex = optionIndex;
      
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.disabled = true;
      placeholder.selected = true;
      placeholder.textContent = `Select ${this.options[optionIndex].name}`;
      select.appendChild(placeholder);
      
      availableValues.forEach(({ value }) => {
        const opt = document.createElement('option');
        opt.value = value;
        opt.textContent = value;
        select.appendChild(opt);
      });
      
      select.addEventListener('change', this.handleChange.bind(this));
      
      wrapper.appendChild(select);
      wrapper.innerHTML += `<svg class="cascading-picker__caret" viewBox="0 0 10 6" aria-hidden="true"><path d="M1 1l4 4 4-4" stroke="currentColor" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
      
      // Replace swatch container with dropdown
      swatchContainer.replaceWith(wrapper);
      if (hiddenInput) hiddenInput.remove();
    }

    updateSelectDropdown(optionIndex) {
      const select = this.querySelector(`select[data-option-index="${optionIndex}"]`);
      if (!select) return;
      
      const availableValues = this.getAvailableValues(optionIndex);
      
      // Clear options except placeholder
      while (select.options.length > 1) select.remove(1);
      
      availableValues.forEach(value => {
        const option = document.createElement('option');
        option.value = value;
        option.textContent = value;
        select.appendChild(option);
      });
      
      select.disabled = this.selections[optionIndex - 1] === null;
      select.selectedIndex = 0;
    }

    getAvailableValues(optionIndex) {
      let matchingVariants = this.variants;
      
      for (let i = 0; i < optionIndex; i++) {
        if (this.selections[i] !== null) {
          matchingVariants = matchingVariants.filter(v => v.options[i] === this.selections[i]);
        }
      }
      
      return [...new Set(matchingVariants.map(v => v.options[optionIndex]))];
    }

    getAvailableValuesWithImages(optionIndex) {
      let matchingVariants = this.variants;
      
      for (let i = 0; i < optionIndex; i++) {
        if (this.selections[i] !== null) {
          matchingVariants = matchingVariants.filter(v => v.options[i] === this.selections[i]);
        }
      }
      
      // Get unique values with their images
      const seen = new Set();
      const result = [];
      
      matchingVariants.forEach(v => {
        const value = v.options[optionIndex];
        if (!seen.has(value)) {
          seen.add(value);
          result.push({
            value,
            image: v.featured_image
          });
        }
      });
      
      return result;
    }

    updateLabels() {
      this.querySelectorAll('[data-selected-label]').forEach((label, i) => {
        label.textContent = this.selections[i] ? `: ${this.selections[i]}` : '';
      });
    }

    checkComplete() {
      const hiddenInput = this.querySelector('[data-selected-variant-id]');
      const numOptions = this.options.length;
      const numSelected = this.selections.filter(s => s !== null).length;

      if (numSelected === numOptions) {
        const variant = this.variants.find(v =>
          v.options.every((opt, i) => opt === this.selections[i])
        );

        if (variant) {
          hiddenInput.value = variant.id;

          // Dispatch variant:selected for components that listen to it
          this.dispatchEvent(new CustomEvent('variant:selected', {
            bubbles: true,
            detail: { variant, sectionId: this.dataset.sectionId }
          }));

          // Dispatch variant:update to enable the Add to Cart button
          this.dispatchEvent(new CustomEvent('variant:update', {
            bubbles: true,
            detail: {
              resource: {
                id: variant.id,
                available: true,
                price: variant.price,
                compare_at_price: variant.compare_at_price,
                sku: variant.sku,
                featured_media: variant.featured_image ? {
                  preview_image: { src: variant.featured_image.url }
                } : null
              },
              sourceId: this.dataset.sectionId,
              data: {
                productId: this.dataset.productId,
                html: document
              }
            }
          }));
        }
      } else {
        hiddenInput.value = '';

        // Dispatch variant:update with null to disable Add to Cart
        this.dispatchEvent(new CustomEvent('variant:update', {
          bubbles: true,
          detail: {
            resource: null,
            sourceId: this.dataset.sectionId,
            data: {
              productId: this.dataset.productId,
              html: document
            }
          }
        }));
      }
    }
  }

  if (!customElements.get('cascading-variant-picker')) {
    customElements.define('cascading-variant-picker', CascadingVariantPicker);
  }
</script>

{% stylesheet %}
  .cascading-picker {
    width: 100%;
  }
  
  .cascading-picker__form {
    display: flex;
    flex-direction: column;
    gap: var(--gap-md, 16px);
  }
  
  .cascading-picker__option > label {
    display: block;
    margin-bottom: var(--margin-2xs, 4px);
    font-weight: var(--font-weight-semibold, 600);
  }
  
  .cascading-picker__selected-value {
    font-weight: normal;
    color: rgb(var(--color-foreground-rgb, 0 0 0) / 0.7);
  }
  
  /* Dropdown styles */
  .cascading-picker__select-wrapper {
    position: relative;
  }
  
  .cascading-picker__select-wrapper select {
    width: 100%;
    padding: var(--padding-sm, 8px) var(--padding-lg, 16px);
    padding-right: 40px;
    appearance: none;
    border: var(--style-border-width-inputs, 1px) solid var(--color-border, #ccc);
    border-radius: var(--style-border-radius-inputs, 4px);
    background: var(--color-background, #fff);
    cursor: pointer;
    font-size: inherit;
  }
  
  .cascading-picker__select-wrapper select:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    background: rgb(0 0 0 / 0.05);
  }
  
  .cascading-picker__caret {
    position: absolute;
    right: 16px;
    top: 50%;
    transform: translateY(-50%);
    width: 10px;
    height: 10px;
    pointer-events: none;
  }
  
  /* Swatch styles */
  .cascading-picker__swatches {
    display: flex;
    flex-wrap: wrap;
    gap: var(--gap-sm, 8px);
  }
  
  .cascading-picker__swatches[data-disabled="true"] {
    display: none;
  }
  
  .cascading-picker__swatch {
    width: 60px;
    height: 60px;
    padding: 0;
    border: 2px solid var(--color-border, #ccc);
    border-radius: var(--style-border-radius-inputs, 4px);
    background: var(--color-background, #fff);
    cursor: pointer;
    overflow: hidden;
    transition: border-color 0.15s ease;
  }
  
  .cascading-picker__swatch:hover {
    border-color: var(--color-foreground, #000);
  }
  
  .cascading-picker__swatch--active {
    border-color: var(--color-foreground, #000);
    border-width: 2px;
  }
  
  .cascading-picker__swatch img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  
  .cascading-picker__swatch--text {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    text-align: center;
    padding: 4px;
    word-break: break-word;
    line-height: 1.1;
  }
{% endstylesheet %}
